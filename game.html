<!-- -->
<hsm-state name="Game" game-control="game" hsm-enter="game.newGame(stream)" hsm-exit="game.quit()" process-control="stream">
  <!-- in general, probably best not to use enter to make state rich changes:
  however, we need to execute a staged-bootstrap, and we can do that via 'gotos' -->
  <hsm-state name="GamePending">
    <hsm-event on="game-created" goto="GameCreated"></hsm-event>
  </hsm-state>
  <hsm-state name="GameCreated" map-control="map" action-service="actions" hsm-enter="actions.bind(game)" hsm-exit="actions.release()">
    <hsm-state player-control="player" hsm-exit="player.destroy()">
      <!--  -->
      <hsm-state name="Initialize">
        <hsm-state name="CreatingPlayer" hsm-enter="player.create('/bin/images/princess.png', 64)">
          <hsm-event on="player-created" goto="LocatingPlayer">
        </hsm-state>
        <hsm-state name="LocatingPlayer" hsm-enter="player.locate()">
          <hsm-event on="player-located" run="map.changeRoom($evt.where)"></hsm-event>
          <hsm-event on="map-loaded" run="player.link()"></hsm-event>
          <hsm-event on="map-loaded" run="game.start()"></hsm-event>
        </hsm-state>
        <hsm-event on="game-started" goto="GameStarted"></hsm-event>
      </hsm-state>
      <!--  -->
      <hsm-state name="GameStarted" parallel="true" modal-control="modal" hsm-exit="modal.dismiss('game stopping')">
        <!-- allow the console once the game has been started; it waits for 'demo-console'  -->
        <ng-include src="'console.html'"></ng-include>
        <!-- might exist to change cursor state -->
        <hsm-state name="MapData">
          <hsm-state name="MapDataLoaded">
            <hsm-event on="map-loading" goto="MapDataLoading"></hsm-event>
          </hsm-state>
          <hsm-state name="MapDataLoading">
            <hsm-event on="map-loaded" goto="MapDataLoaded"></hsm-event>
          </hsm-state>
        </hsm-state>
        <!--  when we start play, we assume that there are events to process -->
        <hsm-state name="Play" hsm-init="WaitingOnProcess" avatar-control="avatar" avatar-size="12" hsm-enter="avatar.create(player.getChara(), map.get('physics'), map.get('pads'))" hsm-exit="avatar.destroy()">
          <hsm-state name="WaitingOnProcess">
            <hsm-event on="stream-empty" goto="GameIsActive"></hsm-event>
          </hsm-state>
          <hsm-state name="WaitingOnMap">
            <hsm-event on="map-loaded" run="player.link()"></hsm-event>
            <hsm-event on="map-loaded" goto="GameIsActive"></hsm-event>
          </hsm-state>
          <hsm-state name="GameIsActive" update-control="update" hsm-enter="update.start('game')" hsm-exit="update.end()">
            <hsm-event on="update-game" run="player.update($evt.dt)"></hsm-event>
            <hsm-event on="update-game" run="map.update($evt.dt)"></hsm-event>
            <ng-include src="'playing.html'"></ng-include>
          </hsm-state>
          <!--  -->
          <hsm-event on="map-loading" goto="WaitingOnMap"></hsm-event>
          <hsm-event on="actions-running" goto="WaitingOnProcess"></hsm-event>
          <hsm-event on="stream-processing" goto="WaitingOnProcess"></hsm-event>
          <!-- happens in zooming only, if process loads a map we are still waiting on process. -->
        </hsm-state>
        <!-- currently, the stream parses at full steam whether we want it to or not.
    it's not controlled by the machine, and it takes some work to synchronize with it. -->
        <hsm-state name="Processor" hsm-enter="stream.process()" hsm-exit="stream.process(false)">
          <hsm-state name="WaitingToProcess">
            <!-- one of the big insights of the morning is responds to events generated by actions, dont try to goto a state in an action. -->
            <hsm-event on="stream-processing" goto="Processing"></hsm-event>
          </hsm-state>
          <!-- parallel due to the lack of multiple enter events -->
          <hsm-state name="Processing" parallel="true">
            <hsm-event on="stream-empty" goto="WaitingToProcess"></hsm-event>
            <!--  -->
            <hsm-state game-listener="roomChange" hsm-enter="roomChange.listen('player', 'x-rel')" hsm-exit="roomChange.silence()">
              <!-- locator is going to raise its own loading events  -->
              <hsm-event on="roomChange" when="$evt.data.prop=='object-whereabouts'" run="map.changeRoom($evt.data.next).then($evt.resolve())"></hsm-event>
            </hsm-state>
            <!--  the default text handler, always active, stores the lines in global memory, primarily for the the sake of the console. FIX: rework to capture into the console directly.-->
            <hsm-state text-control="text" game-listener="printText" hsm-enter="printText.listen('*', ['print', 'say'])" hsm-exit="printText.silence()">
              <hsm-event on="printText" run="text.addLines($evt.tgt, $evt.data).then($evt.resolve())"></hsm-event>
            </hsm-state>
            <!-- other text handlers do other things.... -->
            <hsm-state popup-control="popup" game-listener="reportView" hsm-enter="reportView.listen('*', 'reporting-the-view', true)" hsm-exit="reportView.silence()">
              <hsm-state name="DisplayStoryText" game-listener="popupText" hsm-enter="popupText.listen('_display_', 'print')" hsm-exit="popupText.silence()">
                <hsm-event on="popupText" run="popup.show($evt.data).then($evt.resolve())"></hsm-event>
              </hsm-state>
              <hsm-event on="reportView" when="$evt.start" goto="SilenceRoomEntryText"></hsm-event>
              <hsm-event on="reportView" when="$evt.end" goto="DisplayStoryText"></hsm-event>
              <hsm-state name="SilenceRoomEntryText">
              </hsm-state>
            </hsm-state>
          </hsm-state>
        </hsm-state>
      </hsm-state>
    </hsm-state>
  </hsm-state>
</hsm-state>
